// line 1 "TableLayoutTokenizer.rl"
// Do not edit this file! Generated by Ragel.

package com.esotericsoftware.tablelayout.swing;

import java.util.HashSet;

public class TableLayoutTokenizer extends RagelTokenMaker {
	static public final int PLAIN = 1;
	static public final int STRUCTURE = 2;
	static public final int SYMBOL = 3;
	static public final int NAME = 4;
	static public final int STRING = 5;
	static public final int BRACKET = 6;
	static public final int PROPERTY = 7;
	static public final int KEYWORD = 8;
	static public final int VALUE = 9;
	static public final int CONSTANT = 10;

	protected void parse (int initialTokenType) {

		// line 3 "../src/com/esotericsoftware/tablelayout/swing/TableLayoutTokenizer.java"
		{
			cs = syntax_start;
		}

		// line 7 "../src/com/esotericsoftware/tablelayout/swing/TableLayoutTokenizer.java"
		{
			int _klen;
			int _trans = 0;
			int _acts;
			int _nacts;
			int _keys;
			int _goto_targ = 0;

			_goto:
			while (true) {
				switch (_goto_targ) {
				case 0:
					if (p == pe) {
						_goto_targ = 4;
						continue _goto;
					}
					if (cs == 0) {
						_goto_targ = 5;
						continue _goto;
					}
				case 1:
					_match:
					do {
						_keys = _syntax_key_offsets[cs];
						_trans = _syntax_index_offsets[cs];
						_klen = _syntax_single_lengths[cs];
						if (_klen > 0) {
							int _lower = _keys;
							int _mid;
							int _upper = _keys + _klen - 1;
							while (true) {
								if (_upper < _lower) break;

								_mid = _lower + ((_upper - _lower) >> 1);
								if (data[p] < _syntax_trans_keys[_mid])
									_upper = _mid - 1;
								else if (data[p] > _syntax_trans_keys[_mid])
									_lower = _mid + 1;
								else {
									_trans += (_mid - _keys);
									break _match;
								}
							}
							_keys += _klen;
							_trans += _klen;
						}

						_klen = _syntax_range_lengths[cs];
						if (_klen > 0) {
							int _lower = _keys;
							int _mid;
							int _upper = _keys + (_klen << 1) - 2;
							while (true) {
								if (_upper < _lower) break;

								_mid = _lower + (((_upper - _lower) >> 1) & ~1);
								if (data[p] < _syntax_trans_keys[_mid])
									_upper = _mid - 2;
								else if (data[p] > _syntax_trans_keys[_mid + 1])
									_lower = _mid + 2;
								else {
									_trans += ((_mid - _keys) >> 1);
									break _match;
								}
							}
							_trans += _klen;
						}
					} while (false);

					_trans = _syntax_indicies[_trans];
					cs = _syntax_trans_targs[_trans];

					if (_syntax_trans_actions[_trans] != 0) {
						_acts = _syntax_trans_actions[_trans];
						_nacts = (int)_syntax_actions[_acts++];
						while (_nacts-- > 0) {
							switch (_syntax_actions[_acts++]) {
							case 0:
								// line 23 "TableLayoutTokenizer.rl"
							{
								s = p;
							}
								break;
							case 1:
								// line 24 "TableLayoutTokenizer.rl"
							{
								addToken(PLAIN);
							}
								break;
							case 2:
								// line 25 "TableLayoutTokenizer.rl"
							{
								addToken(STRUCTURE);
							}
								break;
							case 3:
								// line 27 "TableLayoutTokenizer.rl"
							{
								addToken(SYMBOL);
							}
								break;
							case 4:
								// line 28 "TableLayoutTokenizer.rl"
							{
								addCharToken(SYMBOL);
							}
								break;
							case 5:
								// line 29 "TableLayoutTokenizer.rl"
							{
								addToken(NAME);
							}
								break;
							case 6:
								// line 30 "TableLayoutTokenizer.rl"
							{
								addCharToken(BRACKET);
							}
								break;
							case 7:
								// line 31 "TableLayoutTokenizer.rl"
							{
								addToken(STRING);
							}
								break;
							case 8:
								// line 32 "TableLayoutTokenizer.rl"
							{
								addToken(keywords, KEYWORD, PROPERTY);
							}
								break;
							case 9:
								// line 33 "TableLayoutTokenizer.rl"
							{
								addToken(constants, CONSTANT, VALUE);
								try {
									Integer.parseInt(currentToken.getLexeme());
									currentToken.type = CONSTANT;
								} catch (NumberFormatException ignored) {
								}
							}
								break;
							// line 133 "../src/com/esotericsoftware/tablelayout/swing/TableLayoutTokenizer.java"
							}
						}
					}

				case 2:
					if (cs == 0) {
						_goto_targ = 5;
						continue _goto;
					}
					if (++p != pe) {
						_goto_targ = 1;
						continue _goto;
					}
				case 4:
					if (p == eof) {
						int __acts = _syntax_eof_actions[cs];
						int __nacts = (int)_syntax_actions[__acts++];
						while (__nacts-- > 0) {
							switch (_syntax_actions[__acts++]) {
							case 0:
								// line 23 "TableLayoutTokenizer.rl"
							{
								s = p;
							}
								break;
							case 1:
								// line 24 "TableLayoutTokenizer.rl"
							{
								addToken(PLAIN);
							}
								break;
							case 2:
								// line 25 "TableLayoutTokenizer.rl"
							{
								addToken(STRUCTURE);
							}
								break;
							case 3:
								// line 27 "TableLayoutTokenizer.rl"
							{
								addToken(SYMBOL);
							}
								break;
							case 5:
								// line 29 "TableLayoutTokenizer.rl"
							{
								addToken(NAME);
							}
								break;
							case 7:
								// line 31 "TableLayoutTokenizer.rl"
							{
								addToken(STRING);
							}
								break;
							case 8:
								// line 32 "TableLayoutTokenizer.rl"
							{
								addToken(keywords, KEYWORD, PROPERTY);
							}
								break;
							case 9:
								// line 33 "TableLayoutTokenizer.rl"
							{
								addToken(constants, CONSTANT, VALUE);
								try {
									Integer.parseInt(currentToken.getLexeme());
									currentToken.type = CONSTANT;
								} catch (NumberFormatException ignored) {
								}
							}
								break;
							// line 192 "../src/com/esotericsoftware/tablelayout/swing/TableLayoutTokenizer.java"
							}
						}
					}

				case 5:
				}
				break;
			}
		}

		// line 66 "TableLayoutTokenizer.rl"

	}

	// line 202 "../src/com/esotericsoftware/tablelayout/swing/TableLayoutTokenizer.java"
	private static byte[] init__syntax_actions_0 () {
		return new byte[] {0, 1, 0, 1, 1, 1, 2, 1, 3, 1, 6, 1, 7, 1, 9, 2, 0, 1, 2, 1, 0, 2, 1, 4, 2, 1, 6, 2, 2, 0, 2, 2, 6, 2, 3,
			0, 2, 3, 6, 2, 7, 0, 2, 7, 4, 2, 7, 6, 2, 7, 9, 2, 8, 0, 2, 9, 0, 2, 9, 4, 2, 9, 6, 2, 9, 7, 3, 0, 1, 6, 3, 0, 5, 1, 3,
			5, 0, 1, 3, 7, 9, 4, 3, 8, 0, 1, 3, 9, 7, 4, 4, 0, 5, 1, 4, 4, 0, 5, 1, 6, 4, 5, 0, 1, 4, 4, 5, 0, 1, 6, 4, 8, 0, 1, 4,
			4, 8, 0, 1, 6};
	}

	private static final byte _syntax_actions[] = init__syntax_actions_0();

	private static short[] init__syntax_key_offsets_0 () {
		return new short[] {0, 0, 10, 18, 37, 56, 57, 76, 95, 117, 139, 163, 187, 189, 209, 211, 222, 232, 243, 245, 267, 287, 306,
			308, 310, 317, 321, 328, 339, 349, 360};
	}

	private static final short _syntax_key_offsets[] = init__syntax_key_offsets_0();

	private static char[] init__syntax_trans_keys_0 () {
		return new char[] {39, 45, 46, 95, 48, 57, 65, 90, 97, 122, 46, 95, 48, 57, 65, 90, 97, 122, 39, 58, 60, 62, 91, 93, 124,
			40, 42, 44, 46, 48, 57, 65, 90, 97, 122, 123, 125, 39, 58, 60, 62, 91, 93, 124, 40, 42, 44, 46, 48, 57, 65, 90, 97, 122,
			123, 125, 39, 39, 58, 60, 62, 91, 93, 124, 40, 42, 44, 46, 48, 57, 65, 90, 97, 122, 123, 125, 39, 58, 60, 62, 91, 93,
			124, 40, 42, 44, 46, 48, 57, 65, 90, 97, 122, 123, 125, 32, 39, 58, 60, 62, 91, 93, 124, 9, 13, 40, 42, 44, 46, 48, 57,
			65, 90, 97, 122, 123, 125, 32, 39, 58, 60, 62, 91, 93, 124, 9, 13, 40, 42, 44, 46, 48, 57, 65, 90, 97, 122, 123, 125,
			32, 39, 44, 45, 46, 58, 60, 62, 91, 93, 95, 124, 9, 13, 40, 42, 48, 57, 65, 90, 97, 122, 123, 125, 32, 39, 44, 45, 46,
			58, 60, 62, 91, 93, 95, 124, 9, 13, 40, 42, 48, 57, 65, 90, 97, 122, 123, 125, 39, 44, 39, 44, 58, 60, 62, 91, 93, 124,
			40, 42, 45, 46, 48, 57, 65, 90, 97, 122, 123, 125, 39, 44, 39, 44, 45, 46, 95, 48, 57, 65, 90, 97, 122, 39, 44, 46, 95,
			48, 57, 65, 90, 97, 122, 37, 39, 44, 46, 95, 48, 57, 65, 90, 97, 122, 39, 44, 37, 39, 44, 45, 46, 58, 60, 62, 91, 93,
			95, 124, 40, 42, 48, 57, 65, 90, 97, 122, 123, 125, 39, 44, 58, 60, 62, 91, 93, 124, 40, 42, 45, 46, 48, 57, 65, 90, 97,
			122, 123, 125, 39, 58, 60, 62, 91, 93, 124, 40, 42, 44, 46, 48, 57, 65, 90, 97, 122, 123, 125, 58, 93, 58, 93, 32, 39,
			58, 93, 123, 9, 13, 39, 58, 93, 123, 32, 39, 58, 93, 123, 9, 13, 39, 44, 45, 46, 95, 48, 57, 65, 90, 97, 122, 39, 44,
			46, 95, 48, 57, 65, 90, 97, 122, 37, 39, 44, 46, 95, 48, 57, 65, 90, 97, 122, 39, 44, 0};
	}

	private static final char _syntax_trans_keys[] = init__syntax_trans_keys_0();

	private static byte[] init__syntax_single_lengths_0 () {
		return new byte[] {0, 4, 2, 7, 7, 1, 7, 7, 8, 8, 12, 12, 2, 8, 2, 5, 4, 5, 2, 12, 8, 7, 2, 2, 5, 4, 5, 5, 4, 5, 2};
	}

	private static final byte _syntax_single_lengths[] = init__syntax_single_lengths_0();

	private static byte[] init__syntax_range_lengths_0 () {
		return new byte[] {0, 3, 3, 6, 6, 0, 6, 6, 7, 7, 6, 6, 0, 6, 0, 3, 3, 3, 0, 5, 6, 6, 0, 0, 1, 0, 1, 3, 3, 3, 0};
	}

	private static final byte _syntax_range_lengths[] = init__syntax_range_lengths_0();

	private static short[] init__syntax_index_offsets_0 () {
		return new short[] {0, 0, 8, 14, 28, 42, 44, 58, 72, 88, 104, 123, 142, 145, 160, 163, 172, 180, 189, 192, 210, 225, 239,
			242, 245, 252, 257, 264, 273, 281, 290};
	}

	private static final short _syntax_index_offsets[] = init__syntax_index_offsets_0();

	private static byte[] init__syntax_indicies_0 () {
		return new byte[] {0, 2, 3, 3, 3, 3, 3, 1, 4, 4, 4, 4, 4, 1, 6, 7, 9, 9, 10, 11, 7, 7, 7, 8, 8, 8, 9, 5, 13, 14, 16, 16,
			17, 18, 14, 14, 14, 15, 15, 15, 16, 12, 20, 19, 22, 23, 25, 25, 26, 27, 23, 23, 23, 24, 24, 24, 25, 21, 29, 30, 32, 32,
			33, 34, 30, 30, 30, 31, 31, 31, 32, 28, 36, 37, 40, 41, 41, 42, 43, 38, 36, 38, 38, 39, 39, 39, 41, 35, 45, 13, 46, 16,
			16, 17, 18, 14, 45, 14, 14, 15, 15, 15, 16, 44, 48, 49, 50, 51, 52, 50, 53, 53, 54, 55, 52, 50, 48, 50, 52, 52, 52, 53,
			47, 56, 57, 14, 58, 59, 14, 16, 16, 17, 18, 59, 14, 56, 14, 59, 59, 59, 16, 44, 61, 62, 60, 22, 63, 23, 25, 25, 26, 27,
			23, 23, 23, 24, 24, 24, 25, 21, 61, 65, 64, 0, 65, 66, 67, 67, 67, 67, 67, 64, 61, 65, 68, 68, 68, 68, 68, 64, 69, 61,
			70, 68, 68, 68, 68, 68, 64, 61, 70, 64, 72, 73, 75, 74, 4, 74, 76, 76, 77, 78, 4, 74, 74, 4, 4, 4, 76, 71, 73, 75, 74,
			76, 76, 77, 78, 74, 74, 74, 79, 79, 79, 76, 71, 81, 82, 84, 84, 85, 86, 82, 82, 82, 83, 83, 83, 84, 80, 88, 89, 87, 91,
			92, 90, 94, 95, 50, 55, 53, 94, 93, 13, 14, 18, 16, 96, 98, 13, 14, 18, 16, 98, 97, 0, 62, 99, 100, 100, 100, 100, 100,
			60, 61, 62, 101, 101, 101, 101, 101, 60, 102, 61, 103, 101, 101, 101, 101, 101, 60, 61, 103, 60, 0};
	}

	private static final byte _syntax_indicies[] = init__syntax_indicies_0();

	private static byte[] init__syntax_trans_targs_0 () {
		return new byte[] {14, 0, 2, 19, 19, 4, 5, 7, 8, 21, 22, 3, 4, 5, 7, 8, 21, 22, 3, 5, 6, 4, 5, 7, 8, 21, 22, 3, 4, 5, 7, 8,
			21, 22, 3, 4, 9, 5, 7, 8, 10, 21, 22, 3, 4, 9, 10, 4, 11, 12, 7, 2, 19, 21, 22, 3, 11, 12, 2, 19, 12, 13, 27, 1, 14, 15,
			16, 17, 17, 18, 15, 4, 20, 5, 7, 1, 21, 22, 3, 8, 4, 5, 7, 8, 21, 22, 3, 23, 24, 3, 23, 24, 3, 25, 26, 5, 25, 25, 26,
			28, 29, 29, 30, 27};
	}

	private static final byte _syntax_trans_targs[] = init__syntax_trans_targs_0();

	private static byte[] init__syntax_trans_actions_0 () {
		return new byte[] {1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 9, 9, 0, 18, 18, 18, 18, 24, 24, 0, 0, 39, 39, 39, 39, 39, 45, 45, 33, 33,
			0, 33, 33, 36, 36, 82, 51, 82, 82, 0, 110, 82, 115, 115, 18, 0, 21, 15, 1, 15, 15, 15, 15, 15, 66, 66, 0, 18, 18, 18, 0,
			0, 42, 42, 0, 42, 1, 1, 0, 0, 86, 54, 0, 54, 54, 57, 54, 60, 60, 54, 27, 27, 27, 27, 0, 30, 30, 1, 90, 95, 0, 100, 105,
			15, 1, 15, 0, 18, 0, 1, 1, 0, 0, 78};
	}

	private static final byte _syntax_trans_actions[] = init__syntax_trans_actions_0();

	private static byte[] init__syntax_eof_actions_0 () {
		return new byte[] {0, 0, 0, 0, 3, 11, 11, 7, 82, 3, 15, 3, 11, 11, 11, 11, 11, 63, 63, 13, 13, 5, 70, 74, 15, 3, 3, 11, 11,
			48, 48};
	}

	private static final byte _syntax_eof_actions[] = init__syntax_eof_actions_0();

	static final int syntax_start = 3;
	static final int syntax_first_final = 3;
	static final int syntax_error = 0;

	static final int syntax_en_main = 3;

	// line 69 "TableLayoutTokenizer.rl"

	private HashSet<String> keywords = new HashSet();
	{
		keywords.add("debug");
		keywords.add("size");
		keywords.add("width");
		keywords.add("height");
		keywords.add("expand");
		keywords.add("fill");
		keywords.add("align");
		keywords.add("colspan");
		keywords.add("uniform");
		keywords.add("padding");
		keywords.add("paddingTop");
		keywords.add("paddingLeft");
		keywords.add("paddingBottom");
		keywords.add("paddingRight");
		keywords.add("spacing");
		keywords.add("spacingTop");
		keywords.add("spacingLeft");
		keywords.add("spacingBottom");
		keywords.add("spacingRight");
		keywords.add("ignore");
		keywords.add("w");
		keywords.add("h");
		keywords.add("pad");
		keywords.add("padTop");
		keywords.add("padLeft");
		keywords.add("padBottom");
		keywords.add("padRight");
		keywords.add("space");
		keywords.add("spaceTop");
		keywords.add("spaceLeft");
		keywords.add("spaceBottom");
		keywords.add("spaceRight");
	}

	private HashSet<String> constants = new HashSet();
	{
		constants.add("x");
		constants.add("y");
		constants.add("top");
		constants.add("bottom");
		constants.add("left");
		constants.add("right");
		constants.add("center");
		constants.add("min");
		constants.add("pref");
		constants.add("max");
		constants.add("cell");
		constants.add("table");
		constants.add("widget");
	}

	public boolean getCurlyBracesDenoteCodeBlocks () {
		return true;
	}
}
